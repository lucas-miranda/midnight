using System.Collections;
using System.Collections.Generic;

namespace Midnight;


/// <summary>
/// Text ready to be rendered, generated by a <see cref="Font"/>.
/// Contains all glyphs, on the correct order, positioned to compose the text.
/// </summary>
/// <remarks>
/// It's readonly and not suitable for write, if needed look at <see cref="DynamicTextTypesetting"/>.
/// </remarks>
public class TextTypesetting : IEnumerable<GlyphTypesetting> {
    public readonly GlyphTypesetting[] Glyphs;

    public TextTypesetting(IList<GlyphTypesetting> glyphs) {
        Glyphs = new GlyphTypesetting[glyphs.Count];
        glyphs.CopyTo(Glyphs, 0);
    }

    internal TextTypesetting(DynamicTextTypesetting typesetting) : this(typesetting.Glyphs) {
        Size = typesetting.Size;
    }

    /// <summary>
    /// Text size (as em).
    /// </summary>
    public Size2 Size { get; }

    /// <summary>
    /// How many glyphs are registered.
    /// </summary>
    public int Length => Glyphs.Length;

    public IEnumerator<GlyphTypesetting> GetEnumerator() {
        foreach (GlyphTypesetting glyph in Glyphs) {
            yield return glyph;
        }
    }

    IEnumerator IEnumerable.GetEnumerator() {
        return GetEnumerator();
    }
}


/// <summary>
/// Text ready to be rendered, generated by a <see cref="Font"/>.
/// Contains all glyphs, on the correct order, positioned to compose the text.
/// </summary>
public class DynamicTextTypesetting : IEnumerable<GlyphTypesetting> {
    public List<GlyphTypesetting> Glyphs;

    public DynamicTextTypesetting() {
        Glyphs = new();
    }

    public DynamicTextTypesetting(int length) {
        Glyphs = new(length);
    }

    /// <summary>
    /// Text size (as em).
    /// </summary>
    public Size2 Size { get; set; }

    /// <summary>
    /// How many glyphs are registered.
    /// </summary>
    public int Length => Glyphs.Count;

    /// <summary>
    /// Register a glyph.
    /// </summary>
    /// <seealso cref="GlyphTypesetting"/>
    public void Append(Vector2 position, uint unicode, in Glyph data) {
        Glyphs.Add(new(position, unicode, data));
    }

    /// <summary>
    /// Make it read only, by instancing a <see cref="TextTypesetting"/>.
    /// </summary>
    public TextTypesetting ToReadOnly() {
        return new(this);
    }

    public IEnumerator<GlyphTypesetting> GetEnumerator() {
        foreach (GlyphTypesetting glyph in Glyphs) {
            yield return glyph;
        }
    }

    IEnumerator IEnumerable.GetEnumerator() {
        return GetEnumerator();
    }
}


/// <summary>
/// Glyph ready to be rendered, contains all the data to do that.
/// </summary>
/// <param name="Position">Where this glyph is located (using em).</param>
/// <param name="Unicode">It's unicode value.</param>
/// <param name="Data">Data related to provided <see cref="Unicode"/>.</param>
public record struct GlyphTypesetting(Vector2 Position, uint Unicode, in Glyph Data) {
    /// <summary>
    /// Area where glyph is located at atlas texture.
    /// </summary>
    public Rectangle SourceArea => Data.SourceArea;

    /// <summary>
    /// Left and top bearings.
    /// Left bearing is the horizontal distance from the cursor to the leftmost border of the glyph's bounding box.
    /// Top bearing is the vertical distance from the cursor (on the baseline) to the topmost border of the glyph's bounding box.
    /// </summary>
    public Vector2 Bearing => Data.Bearing;

    /// <summary>
    /// Width and height of glyph bounding box.
    /// </summary>
    public Size2 Size => Data.Size;

    /// <summary>
    ///
    /// Distance, on both axis, to move pen position when this glyph is drawn.
    /// </summary>
    public Vector2 Advance => Data.Advance;
}
